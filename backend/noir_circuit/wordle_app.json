{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":7484706192088595050,"abi":{"parameters":[{"name":"targetWord","type":{"kind":"array","length":6,"type":{"kind":"field"}},"visibility":"private"},{"name":"salt","type":{"kind":"field"},"visibility":"private"},{"name":"session_id","type":{"kind":"field"},"visibility":"public"},{"name":"pedersen_hash","type":{"kind":"field"},"visibility":"public"},{"name":"feedback","type":{"kind":"array","length":6,"type":{"kind":"field"}},"visibility":"public"},{"name":"userInput","type":{"kind":"array","length":6,"type":{"kind":"field"}},"visibility":"public"}],"return_type":null,"error_types":{"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"20":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"29":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"61":{"source":"\nfn main(\n    targetWord: [Field;6],  // Private: Secret 6 alphabet Word. Example: SOCKET =  [18, 14, 2, 10, 4, 19]\n    salt: Field, // Private: Salt for the pedersen hash\n    session_id: pub Field, // Public: Unique session id for the game for the current user\n    pedersen_hash: pub Field, // Public: Pedersen hash of the target word\n    feedback: pub [Field;6], // Public: Feedback from the backend\n    userInput: pub [Field;6], // Public: User input\n) {    \n    // check if all the inputs are valid\n    for i in 0..6 {\n        assert(userInput[i] as i32 < 26);\n        assert(targetWord[i] as i32 < 26);\n        assert(feedback[i] as i32 < 3);\n    }\n\n    // Append the session_id and salt to the targetWord and compute the pedersen hash\n    let mut target_word_concatinated: [Field; 8] = [0; 8];\n    for i in 0..6 {\n        target_word_concatinated[i] = targetWord[i];\n    }\n    target_word_concatinated[6] = session_id;\n    target_word_concatinated[7] = salt;\n\n    let computed_pedersen_hash = std::hash::pedersen_hash_with_separator(target_word_concatinated, 0);\n    std::println(computed_pedersen_hash);\n    // Check if the computed pedersen hash is equal to the pedersen hash provided by the backend\n    assert(computed_pedersen_hash == pedersen_hash);\n    \n    // For computed feedback - 2 is green, 1 is yellow, 0 is gray\n    let mut usedWord: [Field;6] = [0;6];\n    let mut computedFeedback: [Field;6] = [0;6];\n\n    for i in 0..6 {\n        if targetWord[i] == userInput[i] {\n            computedFeedback[i] = 2;\n            usedWord[i] = 1;\n        }\n    }\n\n    // Safety: We are using unsafe to mutate the computedFeedback array.\n    let final_computed_feedback: [Field;6] = unsafe {\n     compute_feedback(targetWord, usedWord, computedFeedback, userInput)\n    };\n\n    for i in 0..6 {\n        assert(final_computed_feedback[i] == feedback[i]);\n    }\n}\n\nunconstrained fn compute_feedback(targetWord: [Field;6], mut usedWord: [Field;6], mut computedFeedback: [Field;6], userInput: [Field;6]) -> [Field;6] {\n    for i in 0..6 {\n        if computedFeedback[i] == 2 {\n            // already found. continue to next iteration\n            continue;\n        }\n\n        for j in 0..6 {\n            if i == j {\n                continue;\n            }\n            if targetWord[j] == userInput[i] {\n                if usedWord[j] == 0 {\n                    computedFeedback[i] = 1;\n                    usedWord[j] = 1;\n                }\n                break;\n            }\n        }\n    }\n    computedFeedback\n}\n\n#[test]\nfn test_main() {\n    let targetWord: [Field; 6] = [ 15, 20, 25, 25, 11, 4 ];\n    let salt: Field = 15961106293289049483053884549267218933283397477349071118903763416637371816021;\n    let session_id: Field = 15164179422081492108650238118798357855172074716467477333032613471545131363782;\n    let pedersen_hash: Field = 18268471559028806702341906536271989978706254952411147218938248535688806979828;\n    let feedback: [Field; 6] = [ 0, 0, 0, 0, 1, 0 ];\n    let userInput: [Field; 6] = [ 0, 1, 2, 3, 4, 5 ];\n    main(targetWord, salt, session_id, pedersen_hash, feedback, userInput);\n}\n\n\n\n#[test]\nfn test_pedersen_hash() {\n    let test_inputs: [Field; 3] = [1, 2, 3];\n    let test_hash = std::hash::pedersen_hash_with_separator(test_inputs, 0);\n    std::println(test_hash);\n}\n\n\n","path":"/Users/jayakrishnanashok/Documents/personal/random-projects/noir-apps/wordle_app/src/main.nr"}},"names":["main"],"brillig_names":["decompose_hint","print_unconstrained","compute_feedback","directive_integer_quotient","directive_invert"]}